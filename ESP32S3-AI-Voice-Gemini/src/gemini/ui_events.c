// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.3
// LVGL version: 9.1.0
// Project name: SquareLine_Project

#include "nvs_flash.h"
#include "nvs.h"
#include "ui.h"
#include "wifi_manager.h"      // Wi-Fi manager API
#include "speech_to_text.h"
#include "gemini_client.h"
#include "text_to_speech.h"
#include "storage_manager.h"

#include <stdlib.h>
#include <stdbool.h>
#include <string.h>  // ‚úÖ ADD: Missing string.h
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>

// Forward declarations to satisfy implicit-function calls
void handle_user_text(const char *text);
void ui_manager_set_recording_indicator(bool recording);
void ui_manager_switch_to_chat_screen(void);
void ui_manager_show_toast(const char *msg);

// Voice recording task function
void voice_recording_task(void *parameter);

// Static variables for voice recording state
static bool is_voice_recording = false;
static TaskHandle_t voice_task_handle = NULL;

// ‚úÖ C-compatible max function
static inline int max_int(int a, int b) {
    return (a > b) ? a : b;
}

// ‚úÖ C-compatible string functions
static int find_last_char(const char *str, char ch, int max_pos) {
    int pos = -1;
    for (int i = 0; i < max_pos && str[i] != '\0'; i++) {
        if (str[i] == ch) {
            pos = i;
        }
    }
    return pos;
}

// ‚úÖ NEW: C-compatible function to play text in chunks
void play_text_in_chunks(const char *text) {
    if (!text || strlen(text) == 0) return;
    
    // Create a working copy of the text
    char *workText = malloc(strlen(text) + 1);
    if (!workText) return;
    
    strcpy(workText, text);
    
    // Remove leading/trailing spaces
    int len = strlen(workText);
    while (len > 0 && workText[len-1] == ' ') {
        workText[--len] = '\0';
    }
    
    int start = 0;
    while (start < len) {
        int chunkEnd = start + 40; // 40 character chunks
        
        if (chunkEnd >= len) {
            chunkEnd = len;
        } else {
            // Find last space or punctuation to avoid cutting words
            int lastSpace = find_last_char(workText, ' ', chunkEnd);
            int lastPunct1 = find_last_char(workText, '.', chunkEnd);
            int lastPunct2 = find_last_char(workText, '!', chunkEnd);
            int lastPunct3 = find_last_char(workText, '?', chunkEnd);
            
            int lastPunct = max_int(lastPunct1, max_int(lastPunct2, lastPunct3));
            
            if (lastSpace > start + 20) {
                chunkEnd = lastSpace;
            } else if (lastPunct > start + 15) {
                chunkEnd = lastPunct + 1;
            }
        }
        
        // Extract chunk
        char chunk[100];
        int chunkLen = chunkEnd - start;
        if (chunkLen >= sizeof(chunk)) chunkLen = sizeof(chunk) - 1;
        
        strncpy(chunk, workText + start, chunkLen);
        chunk[chunkLen] = '\0';
        
        // Trim spaces
        while (chunkLen > 0 && chunk[chunkLen-1] == ' ') {
            chunk[--chunkLen] = '\0';
        }
        
        if (chunkLen > 0) {
            char toast_msg[120];
            snprintf(toast_msg, sizeof(toast_msg), "üîä %s", chunk);
            ui_manager_show_toast(toast_msg);
            
            text_to_speech_play(chunk);
            
            // Wait for this chunk to finish before next one
            while (text_to_speech_is_playing()) {
                vTaskDelay(pdMS_TO_TICKS(100));
            }
            
            vTaskDelay(pdMS_TO_TICKS(500)); // Pause between chunks
        }
        
        start = chunkEnd;
    }
    
    free(workText);
}

// Event: start recording when user presses the record button
void chat_screen_on_record_start(lv_event_t * e)
{
    if (is_voice_recording) {
        // Already recording, ignore
        return;
    }
    
    if (text_to_speech_is_playing()) {
        // TTS is playing, stop it first
        text_to_speech_stop();
        ui_manager_show_toast("ƒê√£ d·ª´ng ph√°t √¢m");
        return;
    }
    
    is_voice_recording = true;
    ui_manager_set_recording_indicator(true);
    ui_manager_show_toast("üé§ B·∫Øt ƒë·∫ßu ghi √¢m...");
    
    speech_to_text_start();
    
    // Create voice recording task
    xTaskCreatePinnedToCore(
        voice_recording_task,
        "voice_record",
        12288,  // Increased stack size for audio processing
        NULL,
        3,      // High priority
        &voice_task_handle,
        1       // Core 1
    );
}

// Event: stop recording when user releases the record button
void chat_screen_on_record_stop(lv_event_t * e)
{
    if (!is_voice_recording) {
        return;
    }
    
    // The recording will be stopped by the task itself
    ui_manager_show_toast("‚è≥ ƒêang x·ª≠ l√Ω...");
}

// Voice recording task implementation
void voice_recording_task(void *parameter)
{
    // Record for 5 seconds
    ui_manager_show_toast("‚è≥ ƒêang ghi √¢m... (5 gi√¢y)");
    vTaskDelay(pdMS_TO_TICKS(5000));
    
    // Stop recording and get audio data
    uint8_t *audio_buffer = NULL;
    size_t audio_length = 0;
    speech_to_text_stop(&audio_buffer, &audio_length);
    
    ui_manager_set_recording_indicator(false);
    is_voice_recording = false;
    
    if (audio_buffer && audio_length > 0) {
        ui_manager_show_toast("üîÑ Chuy·ªÉn ƒë·ªïi gi·ªçng n√≥i...");
        
        // Convert speech to text
        char *user_text = speech_to_text_process(audio_buffer, audio_length);
        free(audio_buffer);
        
        if (user_text && strlen(user_text) > 0 && 
            strcmp(user_text, "Kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c gi·ªçng n√≥i") != 0) {
            
            // Process the recognized text
            handle_user_text(user_text);
            free(user_text);
        } else {
            ui_manager_show_toast("‚ùå Kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c gi·ªçng n√≥i");
            chat_screen_append_bot("Xin l·ªói, t√¥i kh√¥ng nghe r√µ. Vui l√≤ng th·ª≠ l·∫°i.");
            if (user_text) free(user_text);
        }
    } else {
        ui_manager_show_toast("‚ùå L·ªói ghi √¢m");
        chat_screen_append_bot("C√≥ l·ªói trong qu√° tr√¨nh ghi √¢m. Vui l√≤ng th·ª≠ l·∫°i.");
        handle_user_text("Xin ch√†o");
    }
    
    ui_manager_show_toast("‚úÖ S·∫µn s√†ng");
    voice_task_handle = NULL;
    vTaskDelete(NULL);
}

// Event: save Wi-Fi & API key settings
void config_screen_on_save(lv_event_t * e)
{
    // Retrieve values from UI text areas
    const char *ssid = lv_textarea_get_text(ui_tfssid);
    const char *pass = lv_textarea_get_text(ui_tfpassword);
    const char *key  = lv_textarea_get_text(ui_tfgeminikey);

    // Save to NVS
    nvs_handle_t h;
    if (nvs_open("config", NVS_READWRITE, &h) == ESP_OK) {
        nvs_set_str(h, "ssid", ssid);
        nvs_set_str(h, "password", pass);
        nvs_set_str(h, "gemini_key", key);
        nvs_commit(h);
        nvs_close(h);
    }

    // Connect to Wi-Fi
    wifi_manager_connect(ssid, pass);

    // Test API key and switch screen
    if (gemini_client_test_key(key) != ESP_OK) {
        ui_manager_show_toast("API Key kh√¥ng h·ª£p l·ªá");
    } else {
        ui_manager_switch_to_chat_screen();
    }
}

// UI helpers to append chat bubbles
void chat_screen_append_user(const char *txt)
{
    lv_textarea_add_text(ui_tachat, "\nB·∫°n: ");
    lv_textarea_add_text(ui_tachat, txt);
}

void chat_screen_append_bot(const char *txt)
{
    lv_textarea_add_text(ui_tachat, "\nAI: ");
    lv_textarea_add_text(ui_tachat, txt);
}

// ‚úÖ MODIFIED: Core flow with C-compatible chunked TTS
void handle_user_text(const char *text)
{
    if (!text || strlen(text) == 0) {
        return;
    }
    
    chat_screen_append_user(text);
    ui_manager_show_toast("ü§ñ ƒêang h·ªèi Gemini...");
    
    char *resp = gemini_client_request(text);
    
    if (resp && strlen(resp) > 0) {
        chat_screen_append_bot(resp);
        ui_manager_show_toast("üîä ƒêang ph√°t √¢m thanh...");
        
        // ‚úÖ Use chunked playback for long responses
        // if (strlen(resp) > 50) {
        //     play_text_in_chunks(resp);
        // } else {
            text_to_speech_play(resp);
        // }
        
        // Log the conversation
        storage_manager_log(text, resp);
        
        free(resp);
    } else {
        chat_screen_append_bot("Xin l·ªói, t√¥i kh√¥ng th·ªÉ tr·∫£ l·ªùi l√∫c n√†y. Vui l√≤ng th·ª≠ l·∫°i.");
        text_to_speech_play("Xin l·ªói, c√≥ l·ªói x·∫£y ra");
        ui_manager_show_toast("‚ùå L·ªói k·∫øt n·ªëi Gemini");
        if (resp) free(resp);
    }
}

// UI manager callbacks
void ui_manager_set_recording_indicator(bool recording)
{
    if (recording) {
        lv_obj_set_style_bg_color(ui_btnTalk, lv_color_hex(0xFF0000), 0);
        // lv_label_set_text(ui_lbTalkStatus, "üé§ ƒêANG GHI √ÇM...");
    } else {
        lv_obj_set_style_bg_color(ui_btnTalk, lv_color_hex(0x00FF00), 0);
        // lv_label_set_text(ui_lbTalkStatus, "üëÜ Ch·∫°m ƒë·ªÉ n√≥i");
    }
}

void ui_manager_switch_to_settings_screen(void)
{
    lv_scr_load(ui_Settings);
}

void ui_manager_switch_to_chat_screen(void)
{
    lv_scr_load(ui_Main);
}

void ui_manager_show_toast(const char *msg)
{
    lv_label_set_text(ui_lbtoast, msg);
}

// Function to check if voice recording is active
bool ui_manager_is_voice_recording(void)
{
    return is_voice_recording;
}